//
// This source file is part of the My Heart Counts iOS application based on the Stanford Spezi Template Application project
//
// SPDX-FileCopyrightText: 2025 Stanford University
//
// SPDX-License-Identifier: MIT
//

public import Foundation


public struct PPGSample: Hashable, Codable, Sendable {
    public let startDate: Date
    /// Nanoseconds since the start date of this specific sample
    public let nanosecondsSinceStart: Int64
    /// How the sensor was being used during the sample reading
    public let usage: [Usage]
    public let opticalSamples: [OpticalSample]
    public let accelerometerSamples: [AccelerometerSample]
    /// Temperature of the PPG sensors in the watch, measured in celsius.
    ///
    /// Might be `nil` if the data reading is invalid, or if temperature is not supported by the hardware.
    public let temperature: Double?
    
    @inlinable
    public init(
        startDate: Date,
        nanosecondsSinceStart: Int64,
        usage: [Usage],
        opticalSamples: [OpticalSample],
        accelerometerSamples: [AccelerometerSample],
        temperature: Double?
    ) {
        self.startDate = startDate
        self.nanosecondsSinceStart = nanosecondsSinceStart
        self.usage = usage
        self.opticalSamples = opticalSamples
        self.accelerometerSamples = accelerometerSamples
        self.temperature = temperature
    }
}


extension PPGSample {
    public struct Usage: RawRepresentable, Hashable, Codable, Sendable {
        public let rawValue: String
        
        @inlinable
        public init(rawValue: String) {
            self.rawValue = rawValue
        }
    }
}


extension PPGSample {
    /// An optical sample from the PPG sensor
    ///
    /// - SeeAlso: https://developer.apple.com/documentation/sensorkit/srphotoplethysmogramopticalsample
    public struct OpticalSample: Hashable, Codable, Sendable {
        public struct NoiseTerms: Hashable, Codable, Sendable {
            public let whiteNoise: Double
            public let pinkNoise: Double
            public let backgroundNoise: Double
            public let backgroundNoiseOffset: Double
            
            @inlinable
            public init(whiteNoise: Double, pinkNoise: Double, backgroundNoise: Double, backgroundNoiseOffset: Double) {
                self.whiteNoise = whiteNoise
                self.pinkNoise = pinkNoise
                self.backgroundNoise = backgroundNoise
                self.backgroundNoiseOffset = backgroundNoiseOffset
            }
        }
        
        public struct Condition: RawRepresentable, Hashable, Codable, Sendable {
            public let rawValue: String
            
            @inlinable
            public init(rawValue: String) {
                self.rawValue = rawValue
            }
        }
        
        /// The index of the LED in use during the sample reading
        public let emitter: Int
        
        /// The set of photodiodes in use during the sample reading
        public let activePhotodiodeIndexes: IndexSet
        
        /// Identifier to distinguish between different signals produced using the same photodiodes and emitters
        ///
        /// To provide the same quality of service certain system conditions may require configuring the
        /// PPG sensor behavior differently while using the same photodiodes and emitters. This
        /// identifier can be used distinguish between the different signals generated by these
        /// different configurations.
        public let signalIdentifier: Int
        
        /// The wavelength in nanometers the emitter was designed to produce while operating at a specific temperature
        public let nominalWavelength: Double
        
        /// a temperature compensated wavelength in nanometers estimate that the emitter is producing
        public let effectiveWavelength: Double
        
        /// Sampling frequency of PPG data in Hz
        public let samplingFrequency: Double
        
        /// nanoseconds since the \c SRPhotoplethysmogramSample start date of the specific optical sample
        public let nanosecondsSinceStart: Int64
        
        /// Flags indicating sensor context or conditions that may effect the sample reading
        ///
        /// These flags can provide some indication of data validity or other system conditions that may influence how the recorded data should be treated.
        public let conditions: [Condition]
        
        public let noiseTerms: NoiseTerms?
        
        public let normalizedReflectance: Double?
        
        @inlinable
        public init(
            emitter: Int,
            activePhotodiodeIndexes: IndexSet,
            signalIdentifier: Int,
            nominalWavelength: Double,
            effectiveWavelength: Double,
            samplingFrequency: Double,
            nanosecondsSinceStart: Int64,
            conditions: [Condition],
            noiseTerms: NoiseTerms?,
            normalizedReflectance: Double?
        ) {
            self.emitter = emitter
            self.activePhotodiodeIndexes = activePhotodiodeIndexes
            self.signalIdentifier = signalIdentifier
            self.nominalWavelength = nominalWavelength
            self.effectiveWavelength = effectiveWavelength
            self.samplingFrequency = samplingFrequency
            self.nanosecondsSinceStart = nanosecondsSinceStart
            self.conditions = conditions
            self.noiseTerms = noiseTerms
            self.normalizedReflectance = normalizedReflectance
        }
    }
}


extension PPGSample {
    public struct AccelerometerSample: Hashable, Codable, Sendable {
        /// nanoseconds since the \c SRPhotoplethysmogramSample start date of the specific accelerometer sample
        public let nanosecondsSinceStart: Int64
        /// Sampling frequency of accelerometer data in Hz
        public let samplingFrequency: Double
        /// X-axis acceleration in G's
        public let x: Double
        /// Y-axis acceleration in G's
        public let y: Double
        /// Z-axis acceleration in G's
        public let z: Double
        
        @inlinable
        public init(nanosecondsSinceStart: Int64, samplingFrequency: Double, x: Double, y: Double, z: Double) {
            self.nanosecondsSinceStart = nanosecondsSinceStart
            self.samplingFrequency = samplingFrequency
            self.x = x
            self.y = y
            self.z = z
        }
    }
}
